/**
 * MIT License
 *
 * Copyright (c) 2020-2023 Estonian Information System Authority
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var webeid=function(e){"use strict";var t;!function(e){e.WARNING="web-eid:warning",e.STATUS="web-eid:status",e.STATUS_ACK="web-eid:status-ack",e.STATUS_SUCCESS="web-eid:status-success",e.STATUS_FAILURE="web-eid:status-failure",e.AUTHENTICATE="web-eid:authenticate",e.AUTHENTICATE_ACK="web-eid:authenticate-ack",e.AUTHENTICATE_SUCCESS="web-eid:authenticate-success",e.AUTHENTICATE_FAILURE="web-eid:authenticate-failure",e.GET_SIGNING_CERTIFICATE="web-eid:get-signing-certificate",e.GET_SIGNING_CERTIFICATE_ACK="web-eid:get-signing-certificate-ack",e.GET_SIGNING_CERTIFICATE_SUCCESS="web-eid:get-signing-certificate-success",e.GET_SIGNING_CERTIFICATE_FAILURE="web-eid:get-signing-certificate-failure",e.SIGN="web-eid:sign",e.SIGN_ACK="web-eid:sign-ack",e.SIGN_SUCCESS="web-eid:sign-success",e.SIGN_FAILURE="web-eid:sign-failure"}(t||(t={}));var E,i=t;!function(e){e.ERR_WEBEID_ACTION_TIMEOUT="ERR_WEBEID_ACTION_TIMEOUT",e.ERR_WEBEID_USER_TIMEOUT="ERR_WEBEID_USER_TIMEOUT",e.ERR_WEBEID_VERSION_MISMATCH="ERR_WEBEID_VERSION_MISMATCH",e.ERR_WEBEID_VERSION_INVALID="ERR_WEBEID_VERSION_INVALID",e.ERR_WEBEID_EXTENSION_UNAVAILABLE="ERR_WEBEID_EXTENSION_UNAVAILABLE",e.ERR_WEBEID_NATIVE_UNAVAILABLE="ERR_WEBEID_NATIVE_UNAVAILABLE",e.ERR_WEBEID_UNKNOWN_ERROR="ERR_WEBEID_UNKNOWN_ERROR",e.ERR_WEBEID_CONTEXT_INSECURE="ERR_WEBEID_CONTEXT_INSECURE",e.ERR_WEBEID_USER_CANCELLED="ERR_WEBEID_USER_CANCELLED",e.ERR_WEBEID_NATIVE_INVALID_ARGUMENT="ERR_WEBEID_NATIVE_INVALID_ARGUMENT",e.ERR_WEBEID_NATIVE_FATAL="ERR_WEBEID_NATIVE_FATAL",e.ERR_WEBEID_ACTION_PENDING="ERR_WEBEID_ACTION_PENDING",e.ERR_WEBEID_MISSING_PARAMETER="ERR_WEBEID_MISSING_PARAMETER"}(E||(E={}));var n=E;class r extends Error{constructor(e){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_MISSING_PARAMETER}}class s extends Error{constructor(e="same action for Web-eID browser extension is already pending"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_ACTION_PENDING}}class o extends Error{constructor(e="extension message timeout"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_ACTION_TIMEOUT}}class a extends Error{constructor(e="Secure context required, see https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_CONTEXT_INSECURE}}class c extends Error{constructor(e="Web-eID extension is not available"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_EXTENSION_UNAVAILABLE}}var _=Object.freeze({VERSION:"2.0.2",EXTENSION_HANDSHAKE_TIMEOUT:1e3,NATIVE_APP_HANDSHAKE_TIMEOUT:5e3,DEFAULT_USER_INTERACTION_TIMEOUT:12e4,MAX_EXTENSION_LOAD_DELAY:1e3});class I extends Error{constructor(e="native application terminated with a fatal error"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_NATIVE_FATAL}}class u extends Error{constructor(e="native application received an invalid argument"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_NATIVE_INVALID_ARGUMENT}}class T extends Error{constructor(e="Web-eID native application is not available"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_NATIVE_UNAVAILABLE}}class A extends Error{constructor(e="an unknown error occurred"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_UNKNOWN_ERROR}}class R extends Error{constructor(e="request was cancelled by the user"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_USER_CANCELLED}}class N extends Error{constructor(e="user failed to respond in time"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_USER_TIMEOUT}}class d extends Error{constructor(e="invalid version string"){super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_VERSION_INVALID}}function l(e,t){return`Update required for Web-eID ${t}`}class S extends Error{constructor(e,t,E){if(e||(E?E.extension&&E.nativeApp?e=l`${"extension and native app"}`:E.extension?e=l`${"extension"}`:E.nativeApp&&(e=l`${"native app"}`):e="requiresUpdate not provided"),super(e),this.name=this.constructor.name,this.code=n.ERR_WEBEID_VERSION_MISMATCH,this.requiresUpdate=E,t){const{library:e,extension:E,nativeApp:i}=t;Object.assign(this,{library:e,extension:E,nativeApp:i})}}}const h={[n.ERR_WEBEID_ACTION_PENDING]:s,[n.ERR_WEBEID_ACTION_TIMEOUT]:o,[n.ERR_WEBEID_CONTEXT_INSECURE]:a,[n.ERR_WEBEID_EXTENSION_UNAVAILABLE]:c,[n.ERR_WEBEID_NATIVE_INVALID_ARGUMENT]:u,[n.ERR_WEBEID_NATIVE_FATAL]:I,[n.ERR_WEBEID_NATIVE_UNAVAILABLE]:T,[n.ERR_WEBEID_USER_CANCELLED]:R,[n.ERR_WEBEID_USER_TIMEOUT]:N,[n.ERR_WEBEID_VERSION_INVALID]:d,[n.ERR_WEBEID_VERSION_MISMATCH]:S};const D=new class{constructor(){this.loggedWarnings=[],this.queue=[],window.addEventListener("message",(e=>this.receive(e)))}receive(e){var t,E,n,r,s,o;if(!/^web-eid:/.test(null===(t=e.data)||void 0===t?void 0:t.action))return;const a=e.data,c=null===(n=null===(E=a.action)||void 0===E?void 0:E.match(/success$|failure$|ack$/))||void 0===n?void 0:n[0],_=this.getInitialAction(a.action),I=this.getPendingMessage(_);if(a.action===i.WARNING)null===(r=a.warnings)||void 0===r||r.forEach((e=>{this.loggedWarnings.includes(e)||(this.loggedWarnings.push(e),console.warn(e.replace(/\n|\r/g,"")))}));else if(I)switch(c){case"ack":clearTimeout(I.ackTimer);break;case"success":this.removeFromQueue(_),null===(s=I.resolve)||void 0===s||s.call(I,a);break;case"failure":{const e=a;this.removeFromQueue(_),null===(o=I.reject)||void 0===o||o.call(I,e.error?function(e){let t;t="string"==typeof e.code&&e.code in h?new(0,h[e.code]):new A;for(const[E,i]of Object.entries(e))t[E]=i;return t}(e.error):e);break}}}send(e,t){if(this.getPendingMessage(e.action))return Promise.reject(new s);if(window.isSecureContext){const E={message:e};return this.queue.push(E),E.promise=new Promise(((e,t)=>{E.resolve=e,E.reject=t})),E.ackTimer=window.setTimeout((()=>this.onAckTimeout(E)),_.EXTENSION_HANDSHAKE_TIMEOUT),E.replyTimer=window.setTimeout((()=>this.onReplyTimeout(E)),t),window.postMessage(e,"*"),E.promise}return Promise.reject(new a)}onReplyTimeout(e){var t;this.removeFromQueue(e.message.action),null===(t=e.reject)||void 0===t||t.call(e,new o)}onAckTimeout(e){var t;clearTimeout(e.replyTimer),this.removeFromQueue(e.message.action),null===(t=e.reject)||void 0===t||t.call(e,new c)}getPendingMessage(e){return this.queue.find((t=>t.message.action===e))}getInitialAction(e){return e.replace(/-success$|-failure$|-ack$/,"")}removeFromQueue(e){const t=this.getPendingMessage(e);clearTimeout(null==t?void 0:t.replyTimer),this.queue=this.queue.filter((t=>t.message.action!==e))}},m=+new Date;async function g(){const e=+new Date;var t;await(t=m+_.MAX_EXTENSION_LOAD_DELAY-e,new Promise((e=>{setTimeout((()=>e()),t)})))}return e.Action=i,e.ErrorCode=n,e.authenticate=async function(e,t){if(await g(),!e)throw new r("authenticate function requires a challengeNonce");const E=_.EXTENSION_HANDSHAKE_TIMEOUT+_.NATIVE_APP_HANDSHAKE_TIMEOUT+((null==t?void 0:t.userInteractionTimeout)||_.DEFAULT_USER_INTERACTION_TIMEOUT),n={action:i.AUTHENTICATE,libraryVersion:_.VERSION,challengeNonce:e,options:t},{unverifiedCertificate:s,algorithm:o,signature:a,format:c,appVersion:I}=await D.send(n,E);return{unverifiedCertificate:s,algorithm:o,signature:a,format:c,appVersion:I}},e.config=_,e.getSigningCertificate=async function(e){await g();const t=_.EXTENSION_HANDSHAKE_TIMEOUT+_.NATIVE_APP_HANDSHAKE_TIMEOUT+2*((null==e?void 0:e.userInteractionTimeout)||_.DEFAULT_USER_INTERACTION_TIMEOUT),E={action:i.GET_SIGNING_CERTIFICATE,libraryVersion:_.VERSION,options:e},{certificate:n,supportedSignatureAlgorithms:r}=await D.send(E,t);return{certificate:n,supportedSignatureAlgorithms:r}},e.sign=async function(e,t,E,n){if(await g(),!e)throw new r("sign function requires a certificate as parameter");if(!t)throw new r("sign function requires a hash as parameter");if(!E)throw new r("sign function requires a hashFunction as parameter");const s=_.EXTENSION_HANDSHAKE_TIMEOUT+_.NATIVE_APP_HANDSHAKE_TIMEOUT+2*((null==n?void 0:n.userInteractionTimeout)||_.DEFAULT_USER_INTERACTION_TIMEOUT),o={action:i.SIGN,libraryVersion:_.VERSION,certificate:e,hash:t,hashFunction:E,options:n},{signature:a,signatureAlgorithm:c}=await D.send(o,s);return{signature:a,signatureAlgorithm:c}},e.status=async function(){await g();const e=_.EXTENSION_HANDSHAKE_TIMEOUT+_.NATIVE_APP_HANDSHAKE_TIMEOUT,t={action:i.STATUS,libraryVersion:_.VERSION};try{const{library:E,extension:i,nativeApp:n}=await D.send(t,e);return{library:E,extension:i,nativeApp:n}}catch(e){throw e.library=_.VERSION,e}},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
